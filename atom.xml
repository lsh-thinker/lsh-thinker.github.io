<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Thinker's blog]]></title>
  <link href="http://lsh-thinker.github.io/atom.xml" rel="self"/>
  <link href="http://lsh-thinker.github.io/"/>
  <updated>2016-05-21T12:28:13+08:00</updated>
  <id>http://lsh-thinker.github.io/</id>
  <author>
    <name><![CDATA[hualong]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Vim常用命令记录]]></title>
    <link href="http://lsh-thinker.github.io/blog/2016/05/21/vimchang-yong-ming-ling-ji-lu/"/>
    <updated>2016-05-21T12:14:39+08:00</updated>
    <id>http://lsh-thinker.github.io/blog/2016/05/21/vimchang-yong-ming-ling-ji-lu</id>
    <content type="html"><![CDATA[<h4><strong>单词大小写</strong></h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- ~  光标下字符大小写转换
</span><span class='line'>- gUw 光标下单词大写 w是范围
</span><span class='line'>- guw 光标下单词小写 </span></code></pre></td></tr></table></div></figure>


<hr />

<h4><strong>分屏</strong></h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- ctrl+w c 关闭当前标签页
</span><span class='line'>- ctrl+w v 将当前标签页垂直分屏
</span><span class='line'>- ctrl+w s 将当前标签页水平分屏
</span><span class='line'>- vsp file 垂直分屏打开文件
</span><span class='line'>- sp file 水平分屏打开文件
</span><span class='line'>- ctrl+w h/j/k/l 跳到左/下/上/右的屏
</span><span class='line'>- ctrl+w 切换屏幕
</span><span class='line'>- qa 退出并关闭所有的屏
</span><span class='line'>- vim -o &lt;filename1&gt; &lt;filename2&gt; 水平分屏打开两个文件
</span><span class='line'>- vim -O &lt;filename1&gt; &lt;filename2&gt; 垂直分屏打开两个文件</span></code></pre></td></tr></table></div></figure>


<hr />

<h4><strong>删除字符</strong></h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- x 删除当前光标位置的字符
</span><span class='line'>- X 删除当前光标位置的前面一个字符
</span><span class='line'>- d$ 删除当前光标位置到行末，和D一样
</span><span class='line'>- dw 删除一个单词，包括空格
</span><span class='line'>- de和dw类似</span></code></pre></td></tr></table></div></figure>


<hr />

<h4><strong>跳转</strong></h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- gg 光标跳到第一行
</span><span class='line'>- G 光标跳到最后一行
</span><span class='line'>- 0 光标跳到行头
</span><span class='line'>- $ 光标跳到行尾
</span><span class='line'>- hjkl 左/下/上/右
</span><span class='line'>- w 跳到下一个单词第一个字符
</span><span class='line'>- e 跳到单词的最后一个字符
</span><span class='line'>- b 跳到单词的第一个字符</span></code></pre></td></tr></table></div></figure>


<hr />

<h4><strong>替换</strong></h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- 行末：$
</span><span class='line'>- 行首：^
</span><span class='line'>- 空格：\s
</span><span class='line'>- 行末空格：\s\+$
</span><span class='line'>- 行首空格：^\+\s
</span><span class='line'>
</span><span class='line'>- :%s/\s\+$// 删除这些每行后面多余的空格
</span><span class='line'>命令前面指明范围是 "%"，所以这会作用于整个文件。
</span><span class='line'>"substitute" 命令的匹配模式是"\s\+$"。表示行末（$）前的一个或者多个（\+）空格（\s）。
</span><span class='line'>替换命令的 "to" 部分是空的："//", 这样就会删除那些匹配的空白字符。
</span><span class='line'>
</span><span class='line'>- :%s/^/xxx 每行的行首都添加一个字符串
</span><span class='line'>- :%s/$/xxx 每行的行尾都添加一个字符串</span></code></pre></td></tr></table></div></figure>


<hr />

<h4><strong>命令</strong></h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- :set ignorecase  或者:set ic 忽略大小写查找
</span><span class='line'>- :set noignorecase 或者:set noic 考虑大小写
</span><span class='line'>- /word_to_search\c  用\c忽略大小写进行搜索</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Tmux常用命令记录]]></title>
    <link href="http://lsh-thinker.github.io/blog/2016/05/21/tmuxchang-yong-ming-ling-ji-lu/"/>
    <updated>2016-05-21T12:14:24+08:00</updated>
    <id>http://lsh-thinker.github.io/blog/2016/05/21/tmuxchang-yong-ming-ling-ji-lu</id>
    <content type="html"><![CDATA[<h3>参考文章</h3>

<ul>
<li><a href="http://blog.jobbole.com/87584/">Tmux 速成教程：技巧和调整</a></li>
<li><a href="http://kumu-linux.github.io/blog/2013/08/06/tmux/">Linux下终端利器tmux</a></li>
</ul>


<hr />

<h3><strong>Pannel</strong></h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- ctrl-b % 将当前panel左右分屏
</span><span class='line'>- ctrl-b " 将当前panel上下分屏
</span><span class='line'>- ctrl-b x 关闭panel
</span><span class='line'>- ctrl-b o 在分屏中切换
</span><span class='line'>- ctrl-b 上下左右 切换到上下左右分隔窗口
</span><span class='line'>- ctrl-b c-方向键 调整分隔窗口大小
</span><span class='line'>- ctrl-b {／｝　交换panel
</span></code></pre></td></tr></table></div></figure>


<h3><strong>Window</strong></h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- ctrl-b c 创建一个窗口
</span><span class='line'>- ctrl-b & 关闭窗口
</span><span class='line'>- ctrl-b p 切换到上个窗口
</span><span class='line'>- ctrl-b n 切换到下一个窗口
</span><span class='line'>- ctrl-b l 切换前后窗口
</span><span class='line'>- ctrl-b ， 重命名当前窗口
</span><span class='line'>- ctrl-b f 在所有窗口中查找关键词
</span><span class='line'>- ctrl-b w 显示所有窗口，并切换</span></code></pre></td></tr></table></div></figure>


<h3><strong>session</strong></h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- ctrl-b s 在session间切换
</span><span class='line'>- ctrl-b d 退出并保存session
</span><span class='line'>- tmux -2 new -s &lt;new-session&gt; 创建一个新的session
</span><span class='line'>- tmux new -s &lt;new-session&gt; 启动一个新的session
</span><span class='line'>- tmux attach 接入已经启动的会话</span></code></pre></td></tr></table></div></figure>


<h3>copy mode</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>1. ctrl+b [ 进入复制模式
</span><span class='line'>2. 按 space 开始复制，移动光标选择复制区域
</span><span class='line'>3. 按 Enter 复制并退出copy-mode
</span><span class='line'>4. 将光标移动到指定位置，按 PREIFX ] 粘贴</span></code></pre></td></tr></table></div></figure>


<h3>other</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- ctrl+b page-up 向上翻页 
</span><span class='line'>- ctrl+b page-dwon 向下翻页 按Enter退出
</span><span class='line'>- ctrl+b ? 弹出所有快捷键
</span><span class='line'>- ctrl+b space 横竖分屏切换
</span><span class='line'>- ctrl+b alt+1
</span><span class='line'>- ctrl+b alt+2</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Git常用命令记录]]></title>
    <link href="http://lsh-thinker.github.io/blog/2016/05/21/gitchang-yong-ming-ling-ji-lu/"/>
    <updated>2016-05-21T11:24:19+08:00</updated>
    <id>http://lsh-thinker.github.io/blog/2016/05/21/gitchang-yong-ming-ling-ji-lu</id>
    <content type="html"><![CDATA[<p><a href="https://higoge.github.io/2015/07/06/git-remote03/">Git远程03：分支的upstream</a></p>

<blockquote><p>工作区->暂存区->版本库</p></blockquote>

<h4><strong>库</strong></h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- git remote add origin git@&lt;server-name&gt;:&lt;path&gt;/&lt;repo-name.git&gt; 关联一个远程库
</span><span class='line'>- git remote show origin 显示</span></code></pre></td></tr></table></div></figure>


<hr />

<h4><strong>分支</strong></h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- git branch 查看分支
</span><span class='line'>- git branch -a 查看远程分支
</span><span class='line'>- git branch -v
</span><span class='line'>- git branch -r
</span><span class='line'>- git remote -v
</span><span class='line'>- git remote add 
</span><span class='line'>
</span><span class='line'>- git branch &lt;branch_name&gt; 创建分支branch_name
</span><span class='line'>- git branch -d &lt;branch_name&gt; 删除分支branch_name
</span><span class='line'>- git branch -D &lt;branch_name&gt; 强制删除本地分支 
</span><span class='line'>
</span><span class='line'>- git branch --set-upstream master origin/next 指定master分支追踪origin/next分支(git 1.7)
</span><span class='line'>- git branch -u upstream/foo bar 本地分支为bar，远程分支为upstream/foo(git 1.8)
</span><span class='line'>- git branch --set-upstream-to=upstream/foo bar(git 1.8)
</span><span class='line'>- git branch -u upstream/foo 设置远程分支为upstream/foo(git 1.8)
</span><span class='line'>- git branch --set-upstream-to=upstream/foo (git 1.8)
</span><span class='line'>- git branch --unset-upstream 取消当前分支的upstream 
</span><span class='line'>- git branch --unset-upstream [分支名] 取消其它分支的upstream
</span><span class='line'>
</span><span class='line'>- git checkout &lt;branch_name&gt; 切换到分支branch_name
</span><span class='line'>- git checkout -b &lt;branch_name&gt; 创建并切换到分支branch_name
</span><span class='line'>- git checkout -b &lt;local_branch&gt; &lt;origin/remote_branch&gt; 创建本地分支，并和远程分支关联
</span><span class='line'>
</span><span class='line'>- git merge &lt;branch_name&gt; 将分支branch_name合并到当前分支
</span><span class='line'>- git merge --no-ff &lt;branch_name&gt; 进行正常的合并，而不是将指针指向develop
</span><span class='line'>- git rebase &lt;branch_name&gt; rebase分支xx到当前分支
</span><span class='line'>
</span><span class='line'>- git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;  取回远程主机某个分支的更新，再与本地的指定分支合并
</span><span class='line'>- git pull origin next 如果远程分支是与当前分支合并，则冒号后面的部分可以省略
</span><span class='line'>- git push -u origin master push的同时设置远程分支，推送master分支到远程origin仓库master分支，并且建立本地分支master的upstream为origin/master</span></code></pre></td></tr></table></div></figure>


<hr />

<h4><strong>git diff</strong></h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- git diff 比较工作区和暂存区的区别
</span><span class='line'>- git diff origin/master master 本地和远程的区别
</span><span class='line'>- git diff HEAD -- FILENAME 比较工作区和版本库中的区别
</span><span class='line'>- git diff HEAD   显示工作区与版本库之间的区别
</span><span class='line'>- git diff --cached 显示暂存区和版本库的区别
</span><span class='line'>- git diff --stat 列出文件
</span><span class='line'>- git diff -- &lt;filename&gt;    只对比给定的文件
</span><span class='line'>- git diff &lt;commit-id1&gt; &lt;commit-id2&gt; 比较两个commit之间的差异</span></code></pre></td></tr></table></div></figure>


<hr />

<h4>git log</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- git log 查看提交的信息
</span><span class='line'>- git log --pretty=oneline &lt;filename&gt;  每个commit的信息只显示一行
</span><span class='line'>- git log -p &lt;filename&gt; 查看文件每次提交的内容
</span><span class='line'>- git log -p &lt;commit-id&gt; 查看某次commit的内容
</span><span class='line'>- git log --stat 
</span><span class='line'>- git log --author='shaohang.lsh' 查询某个用户的提交</span></code></pre></td></tr></table></div></figure>


<hr />

<h4><strong>git stash</strong></h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- git stash 缓存工作区和暂存区的修改，并将其设置为最后一次提交
</span><span class='line'>- git stash apply stash@{0} apply后stash的内容不删除
</span><span class='line'>- git stash pop 恢复时将stash也删除
</span><span class='line'>- git stash list 查看stash的列表
</span><span class='line'>- git stash drop
</span><span class='line'>- git stash show -p 显示第一个stash的内容
</span><span class='line'>- git stash show stash@{1} -p 指定某个stash</span></code></pre></td></tr></table></div></figure>


<p>git stash 复原的时候默认不复原 staged 文件，也就是说如果你运行过 add 命令，使用 git status 查看的话文件应当处于 staged 状态，但是如果你 stash 并复原再看，那个文件的状态又变回 unstaged 了。解决办法就是运行 git stash apply 命令时加上 –index 参数：git stash apply –index，这样就可以完全恢复到 stash 之前的状态。</p>

<hr />

<h4><strong>git checkout</strong></h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- git checkout -- &lt;filename&gt; 将工作区的内容丢弃，用暂存区的内容替换工作区
</span><span class='line'>- git reset HEAD &lt;filename&gt; 将工作区的内容丢弃，暂存区的内容变成工作区，丢弃暂存区的内容
</span><span class='line'>- git reset --hard HEAD^ 回滚到HEAD的上一个commit， 丢弃工作区和暂存区的内容
</span><span class='line'>- git reset --hard &lt;commit-id&gt; 取消merge，回滚到commit前
</span><span class='line'>- git reset --hard &lt;commit-id&gt; 回滚到某个commit-id
</span><span class='line'>- git reset --soft HEAD^ 把HEAD的commit回滚到暂存区</span></code></pre></td></tr></table></div></figure>


<hr />

<h4><strong>其它</strong></h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- git blame 查看文件中的每一行最后修改的作者
</span><span class='line'>- git commit -m "xxx" 将暂存区的代码提交到版本库
</span><span class='line'>- git grep 用于搜索被git索引的文件
</span><span class='line'>- git log 查看某次提交
</span><span class='line'>- git reflog 找到操作的id
</span><span class='line'>- git apply -R {patch} 回滚某个patch
</span><span class='line'>- git rebase --onto master 把当前分支rebase到master上
</span><span class='line'>- git mv -f readme.txt README.txt 修改文件名
</span><span class='line'>- git ls-files 列出所有的文件
</span><span class='line'>- git rm file：从staged区中移除文件，同时把文件从磁盘上删除
</span><span class='line'>- git rm --cached file：从staged区中移除文件，但文件保留在磁盘上
</span><span class='line'>- git cherry-pick &lt;commit-id&gt; 把commit-id的内容apply到当前分支上</span></code></pre></td></tr></table></div></figure>


<p>git add 会将之前修改的添加到暂存区
此时修改文件再git commit， 是不会将第二次修改的内容添加到版本库的，只会将第一次填写的内容进行提交
第一次修改 -> git add -> 第二次修改 -> git commit
第一次修改 -> git add -> 第二次修改 -> git add -> git commit 这样就能提交两次修改
每次修改，如果不add到暂存区，那就不会加入到commit中。</p>

<hr />

<ul>
<li>git 把两个commit合并</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>例如有三个commit， 时间上为t0 t1, t2, t3 
</span><span class='line'>git log 显示的顺序为 t3 t2 t1 t0
</span><span class='line'>此时我们保留t0 不变，并且将t1,t2,t3 合并成t1
</span><span class='line'>git rebase -i t0 表示t0不变，修改t0以后的commit
</span><span class='line'>此时按时间显示三个commit 
</span><span class='line'>    pick t1
</span><span class='line'>    pick t2
</span><span class='line'>    pick t3
</span><span class='line'>我们把t2, t3 合并到t1 里面去，改为
</span><span class='line'>    pick t1 表示选择t1这个commit
</span><span class='line'>    squash t2 表示把t2 合并到前面的commit里面去
</span><span class='line'>    squash t3 表示把t3 合并到前面的commit里面去
</span><span class='line'>保存退出
</span><span class='line'>之后，git log可以看到只剩下 t0 t1</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何免费搭建自己的博客]]></title>
    <link href="http://lsh-thinker.github.io/blog/2016/05/21/ru-he-mian-fei-da-jian-zi-ji-de-bo-ke/"/>
    <updated>2016-05-21T10:55:10+08:00</updated>
    <id>http://lsh-thinker.github.io/blog/2016/05/21/ru-he-mian-fei-da-jian-zi-ji-de-bo-ke</id>
    <content type="html"><![CDATA[<p>之前朋友介绍用octprocess来搭建自己的博客，本来想写篇详细的教程，看着网上都写的挺详细，这里就先记下参考的几篇不错的blog。</p>

<p><a href="http://www.jianshu.com/p/0ac2ac1a8e45">octopress博客搭建和个性化配置</a></p>

<p><a href="http://toughcoder.net/blog/2014/10/16/blogging-like-a-hacker-with-github-pages/">码农的救赎：使用Github Pages搭建博客</a></p>

<p><a href="http://toughcoder.net/blog/2015/04/22/advanced-tricks-of-github-pages-with-octopress/">使用Octopress和Github Pages搭建博客的高级技巧</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[什么是Memory Consistency和Cache Coherence?]]></title>
    <link href="http://lsh-thinker.github.io/blog/2016/02/21/shi-yao-shi-memory-consistencyhe-cache-coherence/"/>
    <updated>2016-02-21T15:16:24+08:00</updated>
    <id>http://lsh-thinker.github.io/blog/2016/02/21/shi-yao-shi-memory-consistencyhe-cache-coherence</id>
    <content type="html"><![CDATA[<p>最近团队内部组织学习并发无锁队列的实现，而要学好这个，其中又有很多基础的概念，今天先谈谈什么是<strong>Memory Consistency</strong>和<strong>Cache Coherence</strong>。</p>

<p>我们都知道，目前大多数计算机的体系结构由一块共享内存（shared memory）和多个处理器（processor）组成。按照摩尔定律，每个处理器的处理能力每18个月就会翻一番，处理器越做越复杂，Intel要保持这个增长速度，在研发上需要投入巨大的成本，基本上已经快达到物理的极限。为了让处理器更好地发挥性能，我们跨入了多核时代，期望在最好的情况下，N个核就能达到原来单个核N倍的处理能力。但是，只要程序中存在多个线程同时操作（Store或Load）同一块共享内存，那么就需要一套机制来协调这些操作之间的先后顺序。而原来单个处理器中为优化性能而采用一系列设计，例如Cache，也变成更加复杂。</p>

<h2>Memory Consistency</h2>

<p>多个处理器同时操作同一块共享内存，这样的设计带来了性能上的提升，但是由于需要有一套机制来保证这些操作的正确性。
先引用一处定义：</p>

<blockquote><p>A memory consistency model, or, more simply, a memory model, is a specification of the allowed behavior of multithreaded programs executing with shared memory. For a multithreaded program executing with specific input data, it specifies what values dynamic loads may return and what the final state of memory is. Unlike a single-threaded execution, multiple correct behaviors are usually allowed.</p></blockquote>

<p>简单的内存操作不外乎Store和Load（先不考虑原子操作），所以组合起来，便有四种可能</p>

<ul>
<li>Store-Load (eg. Store x = 1; Load r1 = y;)</li>
<li>Load-Load (eg. Load r1 = x; Load r2 = y;)</li>
<li>Store-Store (eg. Store x = 1; Store y = 2;)</li>
<li>Load-Store (eg. Load r1 = x; Store y = 2;)</li>
</ul>


<p>程序中可能出现对某个变量x,y的read或write操作，就是Store（写入的内存）或者Load（从内存中读到寄存器中）。而当CPU收到这两条指令时，为了提升执行的性能，它是不一定严格按照程序中所指定的顺序来执行的。例如对于同一个处理器中Store-Store这种情况，Store x = 1; Store y = 2; 交换这两条指令的执行顺序是不影响最终的执行结果的，但是对于多个处理器呢？则可能导致程序出现意想不到的结果。那么Memory Consistency是什么，简而言之，就是规定了这些内存指令，在CPU执行的时候，能否对它们进行reorder。</p>

<h3>Sequential Consistency</h3>

<p>讲到这里，就自然而然引出了Sequential Consistency这种Memory Consistency的概念。同样先引用Lamport的定义：</p>

<blockquote><p>Lamport first called a single processor (core) sequential if “the result of an execution is the same as if the operations had been executed in the order specified by the program.” He then called a multiprocessor sequentially consistent if “the result of any execution is the same as if the operations of all processors (cores) were executed in some sequential
 order, and the operations of each individual processor (core) appear in this sequence in the order specified by its program.”</p></blockquote>

<p>SC是最严格的内存模型,也被成为Strong Consistency Model，自然也会有其他的Weak Consistency Model。SC不允许单个CPU指令之间的reorder。
我们定义&lt;p 表示program order（指令在程序中的先后关系）, &lt;m表示global memory order（指令最后在共享内存中的执行的先后顺序）。那么有：</p>

<ul>
<li>If L(a) &lt;p L(b) =&gt; L(a) &lt;m L(b) // Load -&gt; Load</li>
<li>If L(a) &lt;p S(b) =&gt; L(a) &lt;m S(b) // Load -&gt; Store</li>
<li>If S(a) &lt;p S(b) =&gt; S(a) &lt;m S(b) // Store -&gt; Store</li>
<li>If S(a) &lt;p L(b) =&gt; S(a) &lt;m L(b) // Store -&gt; Load</li>
</ul>


<p>可以看到SC的定义非常直观，当程序指定了两条指令的执行顺序的时候，SC保证这两条指令落到内存中也是按照同样的顺序执行的。但是坏处就是处理器自身的受到了很大的限制，不能对不影响执行结果的指令进行reorder，从而提升CPU的性能。后面可以分析一些更为松散的memory consistency model，它们上面的规则做了一些放松，在性能和用户可编程性之间做了一些trade off。</p>

<h2>Cache Coherence</h2>

<blockquote><p>Coherence seeks to make the caches of a shared-memory system as functionally invisible as the caches in a single-core system</p></blockquote>

<p>现代的处理器本身都带有cache。当处理器A，B从内存中加载x的值并缓存在cache之中，在下一个时刻，处理器A修改了x的值，但是此时处理器B的cache中的值还是原来的x，这就导致了cache incoherence。所以，多个处理器之间，需要通过Cache Coherence Protocal来保证下次读取到的x的值是相同的。</p>

<p>那何为coherence，可以通过如下Coherence invariants来定义：</p>

<ol>
<li><p>Single-Writer, Multiple-Read (SWMR) Invariant. For any memory location A, at any given (logical) time, there exists only a single core that may write to A (and can also read it) or some number of cores that may only read A.</p></li>
<li><p>Data-Value Invariant. The value of the memory location at the start of an epoch is the same as the value of the memory location at the end of its last read–write epoch.</p></li>
</ol>


<p>以上两点保证了多个处理器看到cache的一致性，也就是多个处理器中同时只有一个能够操作读写内存位置，但是同时可以有多个处理器读取同一个内存位置。实现cache coherence有很多种方式和协议，具体以后再详述。</p>

<h2>Memory Consistency VS Cache Coherence</h2>

<p>可以看到，Memory Consistency和Cache Coherence的关注点其实是不一样的。MC关注的是所有线程对所有的内存位置的Store和Load操作必须遵循某个规则，而CC关注的是所有线程对单一的内存位置的修改必须遵循某种规则。Cache coherece是为了让cache在多处理器系统中不需要考虑由于cache的存在而导致的不一致的问题。在没有cache coherence的情况下，仍然可以实现一个Memory Consistency。但是大部分的Memory Consistency Model会采用Cache Coherence来实现一个内存系统，通常可以将它当成是一个黑盒，而不需要关心它的具体实现。</p>

<p>SC这种严格的模型给予了开发者很直观的概念，却为性能优化带来了很多限制。后面再继续聊聊以下几个问题：</p>

<ul>
<li>x86系统是实现了怎样的内存模型，和SC有何不同?</li>
<li>我们可以通过什么指令来告诉CPU保证Store和Load的执行顺序?</li>
<li>除了CPU会reorder以外，还有什么会导致指令执行顺序的改变？</li>
<li>其它的Weak Consistency Model又是怎样？有没有什么应用场景?</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[2016年的计划与希望]]></title>
    <link href="http://lsh-thinker.github.io/blog/2016/01/04/2016nian-de-ji-hua-yu-xi-wang/"/>
    <updated>2016-01-04T22:55:08+08:00</updated>
    <id>http://lsh-thinker.github.io/blog/2016/01/04/2016nian-de-ji-hua-yu-xi-wang</id>
    <content type="html"><![CDATA[<p>一眨眼元旦假期三天就过去了，想想自己也快是步入职场一年的人了。2015年，我从以前熟悉的Java开发跳到了一个C++团队，而且是搞数据库的。虽说容器啊什么都有，跟Java写起来没啥太大的区别，不过还是有很多不习惯。
例如以前Java不用管内存，现在要管，曾经有个bug，跑的结果时对时错，后来发现是那块string的内存空间回收了，如果被覆盖，那么结果就不对，如果结果没有被覆盖，结果就是对的。这个东西你一时半会还测不出来，要靠压测。第二个就是熟悉vim，以前都是用eclipse，当然现在用来查找代码也挺方便。第三个就是C++代码里很多的宏和模版，而Java是没有宏的，让我见识到了很多代码确实用宏写起来相当的风骚。团队里大牛太多，仍旧要好好学习。</p>

<p>想想2016年要干的事情有好多:</p>

<h4>技术</h4>

<ul>
<li>老本行还是技术，除了工作上，应该多看看内功方面的书</li>
<li>多coding coding coding</li>
<li>多逛逛技术论坛，多尝试，拓宽知识面</li>
</ul>


<h4>运动</h4>

<ul>
<li>一周坚持两次运动，现在应该能打两次羽毛球吧</li>
<li>多跑步，虽然我不喜欢跑步，但是发现大汗淋漓的感觉还是很赞。</li>
<li>最近天冷，胖了，发现脑子转的也慢了，目标是要keep fit！</li>
<li>可以尝试培养其它的运动，多学一些技能，例如台球？轮滑?</li>
</ul>


<h4>历史</h4>

<ul>
<li>一直认为程序员也要全面发展，我这人有点强迫症，要看还要挑经典的看。最近对台湾的历史和明朝，宋朝，日本的历史都比较感兴趣。希望新的一年能看的更多，并且写下一些感悟。</li>
<li>2015年看过的小说有武侠的(《射雕英雄传》,《神雕侠侣》，《倚天屠龙记》), 历史的(《明朝那些事》，《德川家康》)，官场的（《沧浪之水》），冒险的（《藏地密码》）等等。</li>
<li>电视剧有《走向共和》，有好几部台湾的电影《海角七号》，《赛德克巴莱》，印度的电影《偶滴神啊》印象比较深刻。</li>
<li>喜欢在洗澡的时候听听《罗辑思维》，然后周末看看《晓说》和《锵锵三人行》，《一虎一席谈》等等。</li>
</ul>


<h4>音乐</h4>

<ul>
<li>音乐上除了喜欢听听粤语歌和一些老歌以外，基本没啥造诣。</li>
<li>学了一段时间的吉他，然后又没坚持下来。口琴也好多年没有吹了，不过这个东西，简单的也能吹吹。</li>
<li>最近很喜欢听日本的一些歌曲，好像也很好听，今年可以挖掘一下。</li>
</ul>


<h4>摄影</h4>

<ul>
<li>去年如愿以偿的买了个单反。然后拍的照片也挺多，技术上嘛，说有很大的改进也没有，但是偶尔能拍的几张不错的照片就挺开心的。</li>
<li>希望新的一年，学好摄影，学点后期制作，学点PS更好。</li>
</ul>


<h4>厨艺</h4>

<ul>
<li>去年开始自己做饭，问老爸老妈，结合下厨房，做了好几样菜，最多还是煲汤，各种排骨汤，土豆牛肉，萝卜饭，清蒸鱼。</li>
<li>新的一年，希望能做得好吃一点，回家展示给爸妈看，哈哈哈~</li>
</ul>


<h4>旅行</h4>

<ul>
<li>这个随缘，比较想去是台湾和日本。</li>
<li>还要把杭州的景点走一遍，公园卡用起来。然后就是周边的城市，南京啊，乌镇啊（一直想着找个妹纸一起去，看来是很难了T_T）</li>
</ul>


<h4>习惯</h4>

<ul>
<li>要养成早睡早起的好习惯，晚上最好是12点睡觉，早上7点半起。</li>
<li>做事情要快，不要选择困难，小的事情无所谓，大的事情可以慎重一点，其实有时结果影响并没有那么大</li>
<li>做事情要狂热一点，从小到大，我都是属于不太会和人争东西的人，要唤醒自己的竞争意识。到社会中，很多东西都是要自己去争取的。</li>
<li>多尝试，不要守着自己的熟悉的区域，要让自己感到每天都有进步</li>
<li>要有危机感</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[程序员的思考]]></title>
    <link href="http://lsh-thinker.github.io/blog/2015/12/27/cheng-xu-yuan-de-si-kao/"/>
    <updated>2015-12-27T21:43:45+08:00</updated>
    <id>http://lsh-thinker.github.io/blog/2015/12/27/cheng-xu-yuan-de-si-kao</id>
    <content type="html"><![CDATA[<p>总想着程序员应该有自己的博客，可以慢慢积累自己学到的一些东西，很赞！</p>

<p>能用vim来写博客，用git来版本控制，用markdown来控制格式。</p>

<p>谢谢孝尼！</p>
]]></content>
  </entry>
  
</feed>
