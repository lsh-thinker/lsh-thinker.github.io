
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Thinker's blog</title>
  <meta name="author" content="hualong">

  
  <meta name="description" content="最近团队内部组织学习并发无锁队列的实现，而要学好这个，其中又有很多基础的概念，今天先谈谈什么是Memory Consistency和Cache Coherence。 我们都知道，目前大多数计算机的体系结构由一块共享内存（shared memory）和多个处理器（processor）组成。 &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://lsh-thinker.github.io/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="Thinker's blog" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script type='text/javascript' src='http://ajax.useso.com/ajax/libs/jquery/1.9.1/jquery.min.js?ver=3.4.2'></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<!-- link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css" -->
<!-- link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css" -->
<link href='http://fonts.useso.com/css?family=Open+Sans:300,400,600&subset=latin,latin-ext' rel='stylesheet'>

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">Thinker's blog</a></h1>
  
    <h2>A blogging framework for hackers.</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="sitesearch" value="lsh-thinker.github.io">
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/02/21/shi-yao-shi-memory-consistencyhe-cache-coherence/">什么是Memory Consistency和Cache Coherence?</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-02-21T15:16:24+08:00'><span class='date'><span class='date-month'>Feb</span> <span class='date-day'>21</span><span class='date-suffix'>st</span>, <span class='date-year'>2016</span></span> <span class='time'>3:16 pm</span></time>
        
           | <a href="/blog/2016/02/21/shi-yao-shi-memory-consistencyhe-cache-coherence/#disqus_thread"
             data-disqus-identifier="http://lsh-thinker.github.io/blog/2016/02/21/shi-yao-shi-memory-consistencyhe-cache-coherence/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>最近团队内部组织学习并发无锁队列的实现，而要学好这个，其中又有很多基础的概念，今天先谈谈什么是<strong>Memory Consistency</strong>和<strong>Cache Coherence</strong>。</p>

<p>我们都知道，目前大多数计算机的体系结构由一块共享内存（shared memory）和多个处理器（processor）组成。按照摩尔定律，每个处理器的处理能力每18个月就会翻一番，处理器越做越复杂，Intel要保持这个增长速度，在研发上需要投入巨大的成本，基本上已经快达到物理的极限。为了让处理器更好地发挥性能，我们跨入了多核时代，期望在最好的情况下，N个核就能达到原来单个核N倍的处理能力。但是，只要程序中存在多个线程同时操作（Store或Load）同一块共享内存，那么就需要一套机制来协调这些操作之间的先后顺序。而原来单个处理器中为优化性能而采用一系列设计，例如Cache，也变成更加复杂。</p>

<h2>Memory Consistency</h2>

<p>多个处理器同时操作同一块共享内存，这样的设计带来了性能上的提升，但是由于需要有一套机制来保证这些操作的正确性。
先引用一处定义：</p>

<blockquote><p>A memory consistency model, or, more simply, a memory model, is a specification of the allowed behavior of multithreaded programs executing with shared memory. For a multithreaded program executing with specific input data, it specifies what values dynamic loads may return and what the final state of memory is. Unlike a single-threaded execution, multiple correct behaviors are usually allowed.</p></blockquote>

<p>简单的内存操作不外乎Store和Load（先不考虑原子操作），所以组合起来，便有四种可能</p>

<ul>
<li>Store-Load (eg. Store x = 1; Load r1 = y;)</li>
<li>Load-Load (eg. Load r1 = x; Load r2 = y;)</li>
<li>Store-Store (eg. Store x = 1; Store y = 2;)</li>
<li>Load-Store (eg. Load r1 = x; Store y = 2;)</li>
</ul>


<p>程序中可能出现对某个变量x,y的read或write操作，就是Store（写入的内存）或者Load（从内存中读到寄存器中）。而当CPU收到这两条指令时，为了提升执行的性能，它是不一定严格按照程序中所指定的顺序来执行的。例如对于同一个处理器中Store-Store这种情况，Store x = 1; Store y = 2; 交换这两条指令的执行顺序是不影响最终的执行结果的，但是对于多个处理器呢？则可能导致程序出现意想不到的结果。那么Memory Consistency是什么，简而言之，就是规定了这些内存指令，在CPU执行的时候，能否对它们进行reorder。</p>

<h3>Sequential Consistency</h3>

<p>讲到这里，就自然而然引出了Sequential Consistency这种Memory Consistency的概念。同样先引用Lamport的定义：</p>

<blockquote><p>Lamport first called a single processor (core) sequential if “the result of an execution is the same as if the operations had been executed in the order specified by the program.” He then called a multiprocessor sequentially consistent if “the result of any execution is the same as if the operations of all processors (cores) were executed in some sequential
 order, and the operations of each individual processor (core) appear in this sequence in the order specified by its program.”</p></blockquote>

<p>SC是最严格的内存模型,也被成为Strong Consistency Model，自然也会有其他的Weak Consistency Model。SC不允许单个CPU指令之间的reorder。
我们定义&lt;p 表示program order（指令在程序中的先后关系）, &lt;m表示global memory order（指令最后在共享内存中的执行的先后顺序）。那么有：</p>

<ul>
<li>If L(a) &lt;p L(b) =&gt; L(a) &lt;m L(b) // Load -&gt; Load</li>
<li>If L(a) &lt;p S(b) =&gt; L(a) &lt;m S(b) // Load -&gt; Store</li>
<li>If S(a) &lt;p S(b) =&gt; S(a) &lt;m S(b) // Store -&gt; Store</li>
<li>If S(a) &lt;p L(b) =&gt; S(a) &lt;m L(b) // Store -&gt; Load</li>
</ul>


<p>可以看到SC的定义非常直观，当程序指定了两条指令的执行顺序的时候，SC保证这两条指令落到内存中也是按照同样的顺序执行的。但是坏处就是处理器自身的受到了很大的限制，不能对不影响执行结果的指令进行reorder，从而提升CPU的性能。后面可以分析一些更为松散的memory consistency model，它们上面的规则做了一些放松，在性能和用户可编程性之间做了一些trade off。</p>

<h2>Cache Coherence</h2>

<blockquote><p>Coherence seeks to make the caches of a shared-memory system as functionally invisible as the caches in a single-core system</p></blockquote>

<p>现代的处理器本身都带有cache。当处理器A，B从内存中加载x的值并缓存在cache之中，在下一个时刻，处理器A修改了x的值，但是此时处理器B的cache中的值还是原来的x，这就导致了cache incoherence。所以，多个处理器之间，需要通过Cache Coherence Protocal来保证下次读取到的x的值是相同的。</p>

<p>那何为coherence，可以通过如下Coherence invariants来定义：</p>

<ol>
<li><p>Single-Writer, Multiple-Read (SWMR) Invariant. For any memory location A, at any given (logical) time, there exists only a single core that may write to A (and can also read it) or some number of cores that may only read A.</p></li>
<li><p>Data-Value Invariant. The value of the memory location at the start of an epoch is the same as the value of the memory location at the end of its last read–write epoch.</p></li>
</ol>


<p>以上两点保证了多个处理器看到cache的一致性，也就是多个处理器中同时只有一个能够操作读写内存位置，但是同时可以有多个处理器读取同一个内存位置。实现cache coherence有很多种方式和协议，具体以后再详述。</p>

<h2>Memory Consistency VS Cache Coherence</h2>

<p>可以看到，Memory Consistency和Cache Coherence的关注点其实是不一样的。MC关注的是所有线程对所有的内存位置的Store和Load操作必须遵循某个规则，而CC关注的是所有线程对单一的内存位置的修改必须遵循某种规则。Cache coherece是为了让cache在多处理器系统中不需要考虑由于cache的存在而导致的不一致的问题。在没有cache coherence的情况下，仍然可以实现一个Memory Consistency。但是大部分的Memory Consistency Model会采用Cache Coherence来实现一个内存系统，通常可以将它当成是一个黑盒，而不需要关心它的具体实现。</p>

<p>SC这种严格的模型给予了开发者很直观的概念，却为性能优化带来了很多限制。后面再继续聊聊以下几个问题：</p>

<ul>
<li>x86系统是实现了怎样的内存模型，和SC有何不同?</li>
<li>我们可以通过什么指令来告诉CPU保证Store和Load的执行顺序?</li>
<li>除了CPU会reorder以外，还有什么会导致指令执行顺序的改变？</li>
<li>其它的Weak Consistency Model又是怎样？有没有什么应用场景?</li>
</ul>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/01/04/2016nian-de-ji-hua-yu-xi-wang/">2016年的计划与希望</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-01-04T22:55:08+08:00'><span class='date'><span class='date-month'>Jan</span> <span class='date-day'>4</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>10:55 pm</span></time>
        
           | <a href="/blog/2016/01/04/2016nian-de-ji-hua-yu-xi-wang/#disqus_thread"
             data-disqus-identifier="http://lsh-thinker.github.io/blog/2016/01/04/2016nian-de-ji-hua-yu-xi-wang/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>一眨眼元旦假期三天就过去了，想想自己也快是步入职场一年的人了。2015年，我从以前熟悉的Java开发跳到了一个C++团队，而且是搞数据库的。虽说容器啊什么都有，跟Java写起来没啥太大的区别，不过还是有很多不习惯。
例如以前Java不用管内存，现在要管，曾经有个bug，跑的结果时对时错，后来发现是那块string的内存空间回收了，如果被覆盖，那么结果就不对，如果结果没有被覆盖，结果就是对的。这个东西你一时半会还测不出来，要靠压测。第二个就是熟悉vim，以前都是用eclipse，当然现在用来查找代码也挺方便。第三个就是C++代码里很多的宏和模版，而Java是没有宏的，让我见识到了很多代码确实用宏写起来相当的风骚。团队里大牛太多，仍旧要好好学习。</p>

<p>想想2016年要干的事情有好多:</p>

<h4>技术</h4>

<ul>
<li>老本行还是技术，除了工作上，应该多看看内功方面的书</li>
<li>多coding coding coding</li>
<li>多逛逛技术论坛，多尝试，拓宽知识面</li>
</ul>


<h4>运动</h4>

<ul>
<li>一周坚持两次运动，现在应该能打两次羽毛球吧</li>
<li>多跑步，虽然我不喜欢跑步，但是发现大汗淋漓的感觉还是很赞。</li>
<li>最近天冷，胖了，发现脑子转的也慢了，目标是要keep fit！</li>
<li>可以尝试培养其它的运动，多学一些技能，例如台球？轮滑?</li>
</ul>


<h4>历史</h4>

<ul>
<li>一直认为程序员也要全面发展，我这人有点强迫症，要看还要挑经典的看。最近对台湾的历史和明朝，宋朝，日本的历史都比较感兴趣。希望新的一年能看的更多，并且写下一些感悟。</li>
<li>2015年看过的小说有武侠的(《射雕英雄传》,《神雕侠侣》，《倚天屠龙记》), 历史的(《明朝那些事》，《德川家康》)，官场的（《沧浪之水》），冒险的（《藏地密码》）等等。</li>
<li>电视剧有《走向共和》，有好几部台湾的电影《海角七号》，《赛德克巴莱》，印度的电影《偶滴神啊》印象比较深刻。</li>
<li>喜欢在洗澡的时候听听《罗辑思维》，然后周末看看《晓说》和《锵锵三人行》，《一虎一席谈》等等。</li>
</ul>


<h4>音乐</h4>

<ul>
<li>音乐上除了喜欢听听粤语歌和一些老歌以外，基本没啥造诣。</li>
<li>学了一段时间的吉他，然后又没坚持下来。口琴也好多年没有吹了，不过这个东西，简单的也能吹吹。</li>
<li>最近很喜欢听日本的一些歌曲，好像也很好听，今年可以挖掘一下。</li>
</ul>


<h4>摄影</h4>

<ul>
<li>去年如愿以偿的买了个单反。然后拍的照片也挺多，技术上嘛，说有很大的改进也没有，但是偶尔能拍的几张不错的照片就挺开心的。</li>
<li>希望新的一年，学好摄影，学点后期制作，学点PS更好。</li>
</ul>


<h4>厨艺</h4>

<ul>
<li>去年开始自己做饭，问老爸老妈，结合下厨房，做了好几样菜，最多还是煲汤，各种排骨汤，土豆牛肉，萝卜饭，清蒸鱼。</li>
<li>新的一年，希望能做得好吃一点，回家展示给爸妈看，哈哈哈~</li>
</ul>


<h4>旅行</h4>

<ul>
<li>这个随缘，比较想去是台湾和日本。</li>
<li>还要把杭州的景点走一遍，公园卡用起来。然后就是周边的城市，南京啊，乌镇啊（一直想着找个妹纸一起去，看来是很难了T_T）</li>
</ul>


<h4>习惯</h4>

<ul>
<li>要养成早睡早起的好习惯，晚上最好是12点睡觉，早上7点半起。</li>
<li>做事情要快，不要选择困难，小的事情无所谓，大的事情可以慎重一点，其实有时结果影响并没有那么大</li>
<li>做事情要狂热一点，从小到大，我都是属于不太会和人争东西的人，要唤醒自己的竞争意识。到社会中，很多东西都是要自己去争取的。</li>
<li>多尝试，不要守着自己的熟悉的区域，要让自己感到每天都有进步</li>
<li>要有危机感</li>
</ul>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/12/27/cheng-xu-yuan-de-si-kao/">程序员的思考</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-12-27T21:43:45+08:00'><span class='date'><span class='date-month'>Dec</span> <span class='date-day'>27</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>9:43 pm</span></time>
        
           | <a href="/blog/2015/12/27/cheng-xu-yuan-de-si-kao/#disqus_thread"
             data-disqus-identifier="http://lsh-thinker.github.io/blog/2015/12/27/cheng-xu-yuan-de-si-kao/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>总想着程序员应该有自己的博客，可以慢慢积累自己学到的一些东西，很赞！</p>

<p>能用vim来写博客，用git来版本控制，用markdown来控制格式。</p>

<p>谢谢孝尼！</p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
    <a href="/blog/archives">Blog Archives</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2016/02/21/shi-yao-shi-memory-consistencyhe-cache-coherence/">什么是Memory Consistency和Cache Coherence?</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/01/04/2016nian-de-ji-hua-yu-xi-wang/">2016年的计划与希望</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/12/27/cheng-xu-yuan-de-si-kao/">程序员的思考</a>
      </li>
    
  </ul>
</section>
<section>
  <h1>Categories</h1>
  <ul id="categories">
    <li class='category'><a href='/blog/categories/concurrency/'>concurrency (1)</a></li>
<li class='category'><a href='/blog/categories/other/'>other (2)</a></li>
 
  </ul>
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2016 - hualong -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'longshaohang';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>











</body>
</html>
